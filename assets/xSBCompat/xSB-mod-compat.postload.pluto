local loadedModPaths = assets.loadedSources()
local loadedMods = {}
local xSBCompatVersion
for loadedModPaths as loadedMod do
    local metadata = assets.sourceMetadata(loadedMod)
    local modName = metadata.name
    table.insert(loadedMods, modName ?? loadedMod)
    if modName == "xSBCompat" then
        xSBCompatVersion = metadata.version
    end
end

local logInfo = |modName| -> sb.logInfo($"[xSBCompat] Detected and applied compatibility patch to {modName}")
local logError = |modName, error| -> sb.logError($"[xSBCompat] Error while applying compatibility patch for {modName}: {error}")
local modName

local ownedByMod = |assetPath, modName| -> type(modName) == "string" and assets.sourceMetadata(assets.origin(assetPath) or "xSBCompat")?.name == modName
local modAssetsByExtension = |owningMod, extension| -> (table.filter(assets.byExtension(extension), |v| -> ownedByMod(v, owningMod)) |> table.reorder)

if xSBCompatVersion then
    sb.logInfo($"[xSBCompat] Loaded xSBCompat v{xSBCompatVersion} - post-load stage.")
else
    return
end

--- Compatibility patch / bugfix for navigation UI mods ---

local morePlanetInfoPatch = jarray{
    jobject{
        op = "test",
        path = "/weatherThreatValues"
    },
    jobject{
        op = "add",
        path = "/weatherThreatValues/clear",
        value = 0.0
    }
}
-- The patch must be done post-load to «catch» the existence of More Planet Info and other navigation UI mods.
assets.add("/interface/cockpit/cockpit.config.postproc", morePlanetInfoPatch)
assets.patch("/interface/cockpit/cockpit.config", "/interface/cockpit/cockpit.config.postproc")

--- Compatibility patch for Sayter's Frackin' Universe ---

if not "FrackinUniverse" in loadedMods then goto skipFUPatch end
modName = "Sayter's Frackin' Universe"

xpcall(|| -> do
    local needsPatch = "/scripts/fupower.lua"
    local needsPatch2 = "/objects/crafting/clonelab/clonelab.lua"

    local patchCode = [==[
    function power.onNodeConnectionChange(arg,iterations)
        if power.objectPowerType then
            local inputCounter=0
            local outputCounter=0
            if (power.objectPowerType == 'battery') then return arg end
            --sb.logInfo("iterations: %s",iterations)
            iterations=(iterations and iterations + 1) or 1
            if arg then
                entitylist = arg
            else
        -- FezzedOne: Needs JSON type hints here because of xStarbound's Lua-sandbox-related changes to entity messages on same-mastered entities.
                if power.objectPowerType == 'battery' then
                    entitylist = jobject{battery = jarray{entity.id()}, output = jarray{},            all = jarray{entity.id()}}
                elseif power.objectPowerType == 'output' then
                    entitylist = jobject{battery = jarray{},            output = jarray{entity.id()}, all = jarray{entity.id()}}
                else
                    entitylist = jobject{battery = jarray{},            output = jarray{},            all = jarray{entity.id()}}
                end
            end

            -- Update "entitylist" by querying every entity that has its IDs listed in "idlist" array.
            local function updateEntityList(idlist, iterations2)
                for value in pairs(idlist) do
                    powertype = callEntity(value,'isPower',iterations2)
                    if powertype then
                        for j=1,#entitylist.all+1 do
                            if j == #entitylist.all+1 then
                                if powertype == 'battery' then
                                    table.insert(entitylist.battery,value)
                                elseif powertype == 'output' then
                                    table.insert(entitylist.output,value)
                                end

                                table.insert(entitylist.all,value)
                                entitylist = (callEntity(value,'power.onNodeConnectionChange',entitylist,iterations2) or entitylist)
                            elseif entitylist.all[j] == value then
                                break
                            end
                        end
                    end
                end
            end

            if iterations < 100 then
                for i=0,object.inputNodeCount()-1 do
                    if object.isInputNodeConnected(i) then
                        local idlist = object.getInputNodeIds(i)
                        inputCounter=inputCounter+util.tableSize(idlist)

                        updateEntityList(idlist, iterations)
                    end
                end
                for i=0,object.outputNodeCount()-1 do
                    if object.isOutputNodeConnected(i) then
                        local idlist = object.getOutputNodeIds(i)
                        outputCounter=outputCounter+util.tableSize(idlist)

                        updateEntityList(idlist, iterations)
                    end
                end
            else
                sb.logWarn("fupower.lua:power.onNodeConnectionChange: Critical recursion threshhold reached!")
            end
            if arg then
                return entitylist
            else
                power.entitylist = entitylist
                for i=2,#entitylist.all do
                    callEntity(entitylist.all[i],'updateList',entitylist)
                end
            end
            power.lastInputCount=inputCounter
            power.lastOutputCount=outputCounter
        end
    end
    ]==]

    local patchCode2 = [==[
    null = nil -- The script in question expects `null` to be exactly the same as `nil` to avoid a nil dereference error.
    -- This conflicts with xStarbound's special `null` value. Fix your shit, Sayter!
    ]==]

    if assets.exists(needsPatch) then
        local patchedScript = assets.bytes(needsPatch) .. patchCode
        assets.add(needsPatch, patchedScript)
    end
    if assets.exists(needsPatch2) then
        local patchedScript2 = assets.bytes(needsPatch2) .. patchCode2
        assets.add(needsPatch2, patchedScript2)
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end

::skipFUPatch::

--- Compatibility patch for Ceterai's My Enternia ---

if not "My Enternia" in loadedMods then goto skipMyEnterniaPatch end
modName = "Ceterai's My Enternia"

xpcall(|| -> do
    local scriptPath = "/items/buildscripts/alta/object.lua"
    if assets.exists(scriptPath) then
        local objectScript = assets.bytes(scriptPath)
        objectScript = objectScript:gsub('"%%02s"', '"%%2s"')
        assets.add(scriptPath, objectScript)
    end

    local scriptPath2 = "/items/buildscripts/alta/item.lua"
    if assets.exists(scriptPath2) then
        local itemScript = assets.bytes(scriptPath2)
        itemScript = itemScript:gsub("if get%('objectImage'%) then", "if type(get('objectImage')) == 'string' then")
        assets.add(scriptPath2, itemScript)
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipMyEnterniaPatch::

--- Compatibility patch for lophatkao's NPC Mechs ---

if not "xs_crumex" in loadedMods then goto skipNpcMechsPatch end
modName = "lophatkao's NPC Mechs"

xpcall(|| -> do
    -- This patch fixes a typo in one of NPC Mechs' scripts that causes a compatibility issue with xStarbound.
    local modularMechNpc2ScriptPath = "/vehicles/modularmech/modularmechnpc2.lua"

    if assets.exists(modularMechNpc2ScriptPath) then
        local typoLine = "if thisarm.npcfiretime > 0then%-%- %-maxtyme then"
        local patchedLine = "if thisarm.npcfiretime > 0 then -- -maxtyme then"
        local scriptToPatch = assets.bytes(modularMechNpc2ScriptPath)
        assets.erase(modularMechNpc2ScriptPath)
        assets.add(modularMechNpc2ScriptPath, scriptToPatch:gsub(typoLine, patchedLine))
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipNpcMechsPatch::

--- Compatibility patch for me's Nodachi ---

if not "[ex] Nodachi" in loadedMods then goto skipNodachiPatch end
modName = "me's Nodachi"

xpcall(|| -> do
    -- The same exact type of typo as NPC Mechs also exists in this mod.
    local nodachiScriptPath = "/nScripts/nOdachi.lua"

    if assets.exists(nodachiScriptPath) then
        local typoLine = "odachi.aCD == 0then"
        local patchedLine = "odachi.aCD == 0 then"
        local scriptToPatch = assets.bytes(nodachiScriptPath)
        assets.erase(nodachiScriptPath)
        local result, numChanges = scriptToPatch:gsub(typoLine, patchedLine)
        if numChanges == 0 then
            sb.logInfo("[xSBCompat::Debug] Nodachi script not patched!")
        end
        assets.add(nodachiScriptPath, result)
    else
        sb.logInfo("[xSBCompat::Debug] Nodachi script not found!")
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipNodachiPatch::

--- Compatibility patch for Patman's Infiniter Inventory ---

-- FezzedOne: This patch is needed to replace the unsafe smuggled Infiniter Inventory pane callback with a pane message,
-- since xStarbound does not allow unsafe callback smuggling for good reasons. Also includes forward compatibility for
-- any future usage of pane or widget callbacks on the stock inventory pane. The engine call for shift-clicking items
-- from the stock inventory is not currently implemented in xStarbound, so that feature isn't supported.

if not "pat_infinv" in loadedMods then goto skipInfiniterInventoryPatch end
modName = "Patman's Infiniter Inventory"

xpcall(|| -> do
    local infiniterInventoryPlayerScriptPath = "/pat/infinv/binds/player.lua"
    local infiniterInventoryPlayerScript = assets.bytes(infiniterInventoryPlayerScriptPath)
    local infiniterInventoryPlayerScriptPatch = [==[
        local dismissFunc = function()
            world.sendEntityMessage(player.id(), "Patman::InfiniterInventory::dismiss")
        end
        local infInvIsOpen = function()
            return world.sendEntityMessage(player.id(), "Patman::InfiniterInventory::isOpen"):result()
        end
        shared.pat_infinv_dismiss = dismissFunc

        local patman_oldOpen = open
        function open(...)
            -- FezzedOne: Emulate the way the smuggled Lua value is used as a check for the pane being open on xStarbound.
            if not infInvIsOpen() then
                shared.pat_infinv_dismiss = nil
            end
            local ret = patman_oldOpen(...)
            -- FezzedOne: The dismissal function gets cleared whenever the pane is dismissed. Reset it.
            shared.pat_infinv_dismiss = dismissFunc
            return ret
        end

        local patman_oldUninit = uninit
        function uninit()
            -- FezzedOne: Ensure the Infiniter Inventory isn't opened automatically as soon as the player gets in
            -- game with a character.
            jremove(storage, "restore")
        end
    ]==]
    assets.add(infiniterInventoryPlayerScriptPath, infiniterInventoryPlayerScript .. infiniterInventoryPlayerScriptPatch)

    local infiniterInventoryPaneScriptPath = "/pat/infinv/InfiniteInventory.lua"
    local infiniterInventoryPaneScript = assets.bytes(infiniterInventoryPaneScriptPath)
    local infiniterInventoryPaneScriptPatch = [==[
        -- FezzedOne: Includes a full compatibility bridge for all possible inventory pane/widget binds (except 
        -- imperfect `addWidget` compatibility) for forward compatibility with updates to Infiniter Inventory that
        -- might modify the stock inventory pane.

        local patman_infInv_oldInit = init

        local __generateCanvasWidgetBridge = function(canvasName)
            local canvasWidgetBridge = {}
            local canvasWidgetBridgeMetatable = {
                __canvasWidgetName = canvasName,
                __index = function(self, key)
                    local savedKey = key
                    return function(...)
                        return world.sendEntityMessage("Patman::canvasWidgetBridge", self.__canvasWidgetName, savedKey, ...):result()
                    end
                end
            }
            setmetatable(canvasWidgetBridge, canvasWidgetBridgeMetatable)
            return canvasWidgetBridge
        end
    
        local __generateWidgetBridge = function()
            local widgetBridge = {}
            local widgetBridgeMetatable = {
                __index = function(_, key)
                    local savedKey = key
                    if savedKey == "bindCanvas" then
                        return function(canvasName)
                            return __generateCanvasWidgetBridge(canvasName)
                        end
                    else
                        return function(...)
                            return world.sendEntityMessage("Patman::widgetBridge", savedKey, ...):result()
                        end
                    end
                end
            }
            setmetatable(widgetBridge, widgetBridgeMetatable)
            return widgetBridge
        end

        function init()
            -- FezzedOne: Required for the mod keybind to work properly on xStarbound.
            message.setHandler("Patman::InfiniterInventory::isOpen", function (_, isLocal)
                return true
            end)
            message.setHandler("Patman::InfiniterInventory::dismiss", function (_, isLocal)
                pane.dismiss()
            end)
            interface.bindRegisteredPane = function(paneName)
                if string.lower(paneName) == "inventory" then
                    local paneBridge = {}
                    local paneBridgeMetatable = {
                        __index = function(_, key)
                            local savedKey = key
                            if savedKey == "toWidget" then
                                return function()
                                    return __generateWidgetBridge()
                                end
                            else
                                return function(...)
                                    return world.sendEntityMessage("Patman::paneBridge", savedKey, ...):result()
                                end
                            end
                        end
                    }
                    setmetatable(paneBridge, paneBridgeMetatable)
                    return paneBridge
                else
                    return nil
                end
            end
            patman_infInv_oldInit()
        end
    ]==]
    assets.add(infiniterInventoryPaneScriptPath, infiniterInventoryPaneScript .. infiniterInventoryPaneScriptPatch)

    local inventoryBridgeScript = [==[
        -- FezzedOne: Bridge script needed to emulate OpenStarbound's version of `interface.bindRegisteredPane`.

        local inventoryPaneCallbacks, inventoryWidgetCallbacks
        function init()
            inventoryPaneCallbacks = interface.bindRegisteredPane("Inventory")
            inventoryWidgetCallbacks = inventoryPaneCallbacks.toWidget()
            message.setHandler("Patman::canvasWidgetBridge", function (_, isLocal, canvasName, funcKey, ...)
                if isLocal and inventoryWidgetCallbacks then
                    local canvasCallbacks = inventoryWidgetCallbacks.bindCanvas(canvasName)
                    if canvasCallbacks then
                        return canvasCallbacks[funcKey](canvasCallbacks, ...)
                    else
                        return nil
                    end
                end
            end)
            message.setHandler("Patman::widgetBridge", function (_, isLocal, funcKey, ...)
                if isLocal and inventoryWidgetCallbacks then
                    return inventoryWidgetCallbacks[funcKey](...)
                end
            end)
            message.setHandler("Patman::paneBridge", function (_, isLocal, funcKey, ...)
                if isLocal and inventoryPaneCallbacks then
                    return inventoryPaneCallbacks[funcKey](...)
                end
            end)
        end
    ]==]
    local inventoryBridgeScriptPath = "/pat/xsb/inventory_bridge.lua"
    assets.add(inventoryBridgeScriptPath, inventoryBridgeScript)
    local clientConfig = jobject{
        universeScriptContexts = jobject{ 
            pat_infinv = jarray{ 
                inventoryBridgeScriptPath
            }
        }
    }
    assets.add("/client.config.xSB-postproc", clientConfig)
    assets.patch("/client.config", "/client.config.xSB-postproc")

    -- FezzedOne: Fix for a Z-level bug in Infiniter Inventory's pane config that puts the editor controls behind the inventory slots, rendering the editor unusable.
    local paneConfigPath = "/pat/infinv/infinv.config"
    local paneConfig = assets.json(paneConfigPath)
    paneConfig.gui.editorLayout.zlevel = 1
    assets.add(paneConfigPath, paneConfig)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipInfiniterInventoryPatch::

--- Compatibility patch for Patman's Save Inventory Position ---

if not "pat_saveInventoryPosition" in loadedMods then goto skipInventoryResetPatch end
modName = "Patman's Save Inventory Position"

xpcall(|| -> do
    local saveInventoryPositionScriptPath = "/pat_saveInventoryPosition.lua"
    local inventoryResetCommandScriptPath = "/scripts/patmanInventoryResetCommandHandler.lua"

    local saveInventoryPositionScript = assets.bytes(saveInventoryPositionScriptPath)

    local clientConfig = jobject{
        universeScriptContexts = jobject{ 
            pat_saveInventoryPosition = jarray{ 
                saveInventoryPositionScriptPath
            }
        }
    }
    assets.add("/client.config.xSB-postproc", clientConfig)
    assets.patch("/client.config", "/client.config.xSB-postproc")

    local playerConfig = jobject{
        genericScriptContexts = jobject{
            pat_saveInventoryPosition = inventoryResetCommandScriptPath
        }
    }
    assets.add("/player.config.xSB-postproc", playerConfig)
    assets.patch("/player.config", "/player.config.xSB-postproc")

    local saveInventoryPositionPatch = [==[
        -- Note: The patched mod script only works properly when `"safeScripts"` is *enabled*.

        local patman_saveInv_oldInit = init

        local oldPrimaryUuid = nil
        InventoryPane = nil

        function init()
            -- Need to use a persistent reference on xSB so that a pane callback is accessible on `uninit`.
            InventoryPane = interface.bindRegisteredPane(PaneName)
            local old_bindRegisteredPane = interface.bindRegisteredPane
            interface.bindRegisteredPane = function(paneName)
                if paneName == "Inventory" then
                    return InventoryPane
                else
                    return old_bindRegisteredPane(paneName)
                end
            end

            -- The message table is not currently available in universe client scripts on xClient.
            message ??= {
                setHandler = function() end
            }
            patman_saveInv_oldInit()
            script.setUpdateDelta(1)

            oldPrimaryUuid = world.primaryPlayerUuid()
        end

        local resetIdentifier <const> = "patman::resetInventoryPosition"

        function update(dt)
            if world.getGlobal(resetIdentifier) then
                interface.bindRegisteredPane(PaneName).setPosition({0, 0})
                world.setGlobal(resetIdentifier, null)
            end

            oldPrimaryUuid = primaryUuid
        end
    ]==] .. "\n"
    assets.add(saveInventoryPositionScriptPath, saveInventoryPositionScript .. saveInventoryPositionPatch)

    local inventoryResetCommandScript = [==[
        local resetIdentifier <const> = "patman::resetInventoryPosition"

        function init()
            message.setHandler("/resetinventoryposition", |_, isLocal| ->
                (isLocal and player.uniqueId() == world.primaryPlayerUuid())
                    ? (world.setGlobal(resetIdentifier, true) or "Reset inventory position.")
                    : "^red;Attempted to invoke ^orange;/resetinventoryposition^red; on a non-local or secondary player!^reset;")
        end
    ]==] .. "\n"
    assets.add(inventoryResetCommandScriptPath, inventoryResetCommandScript)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipInventoryResetPatch::

--- Compatibility patch for keybinds in Patman's Ruler ---

if not "pat_ruler" in loadedMods then goto skipRulerPatch end
modName = "Patman's Ruler"

xpcall(|| -> do
    local rulerScriptPath = "/pat/ruler/ruler.lua"

    local rulerScript = assets.bytes(rulerScriptPath)
    local rulerScriptPatch = [==[
        local starExtensions = true -- Fool the mod script into thinking it's running on StarExtensions.
    ]==] .. "\n"
    assets.add(rulerScriptPath, rulerScriptPatch .. rulerScript)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipRulerPatch::

--- Compatibility patch for Emmaker's Limited Lives ---

if not "LimitedLives" in loadedMods then goto skipLimitedLivesPatch end
modName = "Emmaker's Limited Lives"

xpcall(|| -> do
    local limitedLivesScriptPath = "/scripts/player/limitedLives.lua"

    local limitedLivesScript = assets.bytes(limitedLivesScriptPath)
    local limitedLivesScriptPatch = [==[
        local starExtensions = true -- Fool the mod script into thinking it's running on StarExtensions.
    ]==] .. "\n"
    assets.add(limitedLivesScriptPath, limitedLivesScriptPatch .. limitedLivesScript)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipLimitedLivesPatch::

--- Compatibility patch for SomethingRetarded's Universal BYOS Patcher ---

if not "sr_oSB_UBYOS" in loadedMods then goto skipUniversalByosPatch end
modName = "SomethingRetarded's Universal BYOS Patcher"

xpcall(|| -> do
    local universalByosScriptPath = "/sr_ubyos.lua"
    local universalByosScript = assets.bytes(universalByosScriptPath)

    local universalByosScriptPatch = [==[
        -- FezzedOne: Need to emulate OpenStarbound's `assets.sourcePaths` here.

        assets.sourcePaths = function(addMetadata)
            if addMetadata then
                local assetSources = assets.sources()
                local returnValue = jobject{}
                for assetSources as source do
                    returnValue[source] = assets.sourceMetadata(source)
                        |> |x| -> type(x.name) == "string" ? x : rawset(x, "name", sb.printJson(x.name))
                        |> |x| -> type(x.friendlyName) == "string" ? x : rawset(x, "friendlyName", sb.printJson(x.friendlyName))
                end
                return returnValue
            else
                return assets.sources()
            end
        end

        ---<< BEGINNING OF ORIGINAL UNIVERSAL BYOS PATCHER SCRIPT >>---  
    ]==] .. "\n"

    assets.add(universalByosScriptPath .. ".frontload", universalByosScriptPatch .. universalByosScript)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipUniversalByosPatch::

--- Compatibility patch for RingSpokes' Unde Venis ---

if not "UndeVenis" in loadedMods then goto skipUndeVenisPatch end
modName = "RingSpokes' Unde Venis"

xpcall(|| -> do
    local undeVenisScriptPath = "/interface/undevenis/undevenis.lua"
    local undeVenisScript = assets.bytes(undeVenisScriptPath)

    local undeVenisScriptPatch = "\n" .. [==[
        ---<< ORIGINAL UNDE VENIS SCRIPT ENDS HERE >>---

        UNKNOWN = "<unknown>"

        function init()
            root.assetOrigin = root.assetSource
            root.assetSourcePaths = function(addMetadata)
                if addMetadata then
                    local assetSources = root.assetSources()
                    local returnValue = jobject{}
                    for assetSources as source do
                        returnValue[source] = root.assetSourceMetadata(source)
                          |> |x| -> type(x.name) == "string" ? x : rawset(x, "name", sb.printJson(x.name))
                          |> |x| -> type(x.friendlyName) == "string" ? x : rawset(x, "friendlyName", sb.printJson(x.friendlyName))
                    end
                    return returnValue
                else
                    return root.assetSources()
                end
            end
        end   
    ]==]
    assets.add(undeVenisScriptPath, undeVenisScript .. undeVenisScriptPatch)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipUndeVenisPatch::

--- Compatibility patch for James' Wardrobe Cumulative Patch ---

if not "[oSB] Wardrobe Cumulative Patch" in loadedMods then goto skipWardrobeCumulativePatch end
modName = "James' Wardrobe Cumulative Patch"

xpcall(|| -> do
    local wardrobeScriptPath = "/wardrobe_postload.lua"
    local wardrobeScript = assets.bytes(wardrobeScriptPath)

    local wardrobeScriptPatch = [==[
        assets.sourcePaths = function(addMetadata)
            if addMetadata then
                local assetSources = assets.sources()
                local returnValue = jobject{}
                for assetSources as source do
                    returnValue[source] = assets.sourceMetadata(source)
                end
                return returnValue
            else
                return assets.sources()
            end
        end

        ---<< ORIGINAL WARDROBE PATCH SCRIPT BEGINS HERE >>---
    ]==] .. "\n"
    assets.add(wardrobeScriptPath .. ".frontload", wardrobeScriptPatch .. wardrobeScript)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipWardrobeCumulativePatch::

--- Compatibility patch for Silver Sokolova's Betabound ---
-- This patch ensures the mod works as if on a vanilla client, but doesn't enable anything locked behind OpenStarbound checks.

if not "XRC_BETA_STARBOUND" in loadedMods then goto skipBetaboundPatch end
modName = "Silver Sokolova's Betabound"

xpcall(|| -> do
    local betaboundStatusControllerScriptPath = "/stats/sb_player_primary.lua"
    local betaboundStatusControllerScript = assets.bytes(betaboundStatusControllerScriptPath)

    local betaboundStatusControllerScriptPatch = [==[
    ---<< END OF ORIGINAL BETABOUND STATUS CONTROLLER SCRIPT >>---

    local betabound_status_init = init
    function init()
        -- `player` is already available in this context on xStarbound, so this fools the code that expects it to have to be smuggled in.
        math.betabound_player = player
        return betabound_status_init()
    end
    ]==]
    assets.add(betaboundStatusControllerScriptPath, betaboundStatusControllerScript .. betaboundStatusControllerScriptPatch)

    local betaboundMainPlayerScriptPath = "/scripts/player/sb_main.lua"
    local betaboundMainPlayerScript = assets.bytes(betaboundMainPlayerScriptPath)

    local betaboundMainPlayerScriptPatch = [==[
    ---<< END OF ORIGINAL BETABOUND PLAYER SCRIPT >>---

    local betabound_player_init = init
    function init()
        -- `mcontroller` is already available in this context on xStarbound, so this fools the code that expects it to have to be smuggled in.
        math.betabound_mcontroller = mcontroller
        return betabound_player_init()
    end
    ]==]
    assets.add(betaboundMissingAssetScriptPath, betaboundMissingAssetScript .. betaboundMissingAssetScriptPatch)

    local betaboundMissingAssetScriptPath = "/scripts/sb_assetmissing.lua"
    local betaboundMissingAssetScript = assets.bytes(betaboundMissingAssetScriptPath)

    local betaboundMissingAssetScriptPatch = [==[
    ---<< END OF ORIGINAL BETABOUND MISSING ASSET SCRIPT >>---

    -- Gets rid of a potentially slow asset check caused by xStarbound not supporting smuggling.
    function sb_checkClient() return "Vanilla" end
    ]==]
    assets.add(betaboundMissingAssetScriptPath, betaboundMissingAssetScript .. betaboundMissingAssetScriptPatch)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipBetaboundPatch::

--- Compatibility patches for Futara's Dragon Race and Futara's Dragon Engine ---
-- This compatibility patch makes it possible to have these mods *installed* on an xStarbound, but
-- does *not* make dragons playable on xClient, allow the Skill Menu item to be usable,
-- or enable the additional FDR features for Arcana's Grand Cross Zȧnä.

if not "Futara's Dragon Engine" in loadedMods then goto skipFDEPatch end
modName = "Futara's Dragon Engine"

xpcall(|| -> do
    -- Need to make all smuggling-dependent item scripts show a compatibility warning on xStarbound.
    local replacementScriptPath = "/scripts/xsb/disabled_futara_item.lua"
    local replacementScript = [==[
    function init()
        local interactData = {
            title = "Incompatible Item",
            message = "^orange;This item is incompatible with xClient!^reset;\n"
                .. "Switch to a different client to use this item. ^yellow;OpenStarbound^reset; is recommended.",
            sound = "/sfx/interface/nav_insufficient_fuel.ogg"
        }
        player.interact("ShowPopup", interactData)
    end
    ]==]

    assets.add(replacementScriptPath, replacementScript)

    for modAssetsByExtension("Futara's Dragon Engine", "activeitem") as itemPath do
        local itemConfig = assets.json(itemPath)
        itemConfig.scripts = jarray{replacementScriptPath}
        assets.add(itemPath, itemConfig)
    end

    local smugglingScriptsToDisable = {
        "/stats/player_primary_customskill.lua",
        "/stats/player_primary_custombinary.lua",
        "/stats/player_primary_syncskill.lua",
        "/scripts/customrender/customrender.lua",
        "/stats/player_primary_camskill.lua",
        "/scripts/customskill/futaradragon_networkmanager.lua",
        "/interface/statusbars/customskillstatusbar.lua",
        "/interface/skill/customskillmessage/customskillmessage.lua",
        "/player/playergeneraldataruntime.lua",
        "/player/playertracercontroller.lua",
        "/player/playercharactercontroller.lua",
        "/stats/effects/playerskillui/playerskillui.lua",
        "/stats/effects/customskillexpreceiveui/customskillexpreceiveui.lua",
        "/projectiles/localprojectilesystem.lua",
        "/sfx/dynamicsoundeffectmanager.lua",
        "/music/dynamicmusicmanager.lua",
        "/player/playerdatabase.lua"
    }
    local emptyScript = ""

    for smugglingScriptsToDisable as scriptPath do
        assets.add(scriptPath, emptyScript)
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipFDEPatch::

if not "Futara's Dragon Race" in loadedMods then goto skipFDRPatch end
modName = "Futara's Dragon Race"

xpcall(|| -> do
    local replacementScriptPath = "/scripts/xsb/disabled_futara_item.lua"
    if not "Futara's Dragon Engine" in loadedMods then
        sb.logWarn("[xSBCompat] Futara's Dragon Race is missing its Futara's Dragon Engine dependency; install the dependency to disable this warning.")
    
        -- Add the replacement script if it hasn't already been added.
        local replacementScript = [==[
        function init()
            local interactData = {
                title = "Incompatible Item",
                message = "^orange;This item is incompatible with xClient!^reset;\n"
                    .. "Switch to a different client to use this item. ^yellow;OpenStarbound^reset; is recommended.",
                sound = "/sfx/interface/nav_insufficient_fuel.ogg"
            }
            player.interact("ShowPopup", interactData)
        end
        ]==]

        assets.add(replacementScriptPath, replacementScript)
    end

    local smugglingScriptsToDisable = {
        "/stats/effects/FutaraDragonWarpIn/FutaraDragonWarpIn.lua"
    }
    local emptyScript = ""

    for smugglingScriptsToDisable as scriptPath do
        assets.add(scriptPath, emptyScript)
    end

    local dragonCheckScriptPath = "/stats/player_primary_customskill.lua"
    local dragonCheckScript = [==[
    local shownWarningForThisPlayer = false
    local showCompatibilityWarning = function(isThisPlayer)
        if shownWarningForThisPlayer and isThisPlayer then return end
        shownWarningForThisPlayer = true
        local interactData = {
            title = "Incompatible Character",
            message = isThisPlayer
                and ("^orange;This character is incompatible with xClient!^reset;\n\n"
                    .. "Swap to a non-Futara-Dragon character on this client or switch to a different client to play a Futara Dragon. ^yellow;OpenStarbound^reset; is recommended.")
                or ("^orange;A character you just added is incompatible with xClient!^reset; The character has been removed from play.\n\n"
                    .. "Switch to a different client to play a Futara Dragon. ^yellow;OpenStarbound^reset; is recommended."),
            sound = "/sfx/interface/nav_insufficient_fuel.ogg"
        }
        player.interact("ShowPopup", interactData)
    end

    local checkDragonsOnXClient = function()
        if entity.id() == world.mainPlayer() then
            if player.species() == "FutaraDragon" then
                showCompatibilityWarning(true)
            else
                for world.ownPlayers() as playerId do
                    if world.entitySpecies(playerId) == "FutaraDragon" then
                        showCompatibilityWarning(false)
                        local success = world.removePlayer(world.entityUniqueId(playerId))
                        if not success then
                            sb.logError("[xSBCompat] Error occurred while unloading a Futara Dragon character. See above.")
                        end
                    end
                end
            end
        end
    end

    function init()
        checkDragonsOnXClient()
    end
    
    function update(dt)
        checkDragonsOnXClient()
    end
    ]==]

    assets.erase(dragonCheckScriptPath)
    assets.add(dragonCheckScriptPath, dragonCheckScript)

    -- Remove Futara Dragons from the character creator/editor on xClient. This is to prevent accidentally creating a borked dragon character.
    local charCreationPatchScript = [==[
    function patch(config)
        config.speciesOrdering = jarray(table.filter(config.speciesOrdering, |v| -> v ~= "futaradragon")) |> table.reorder
        return config
    end
    ]==]
    assets.add("/interface/windowconfig/charcreation.xsbcompat.patch.pluto", charCreationPatchScript)
    assets.patch("/interface/windowconfig/charcreation.config", "/interface/windowconfig/charcreation.xsbcompat.patch.pluto")

    for modAssetsByExtension("Futara's Dragon Race", "activeitem") as itemPath do
        local itemConfig = assets.json(itemPath)
        itemConfig.scripts = jarray{replacementScriptPath}
        assets.add(itemPath, itemConfig)
    end

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end
::skipFDRPatch::

if not ("Futara's Dragon Race" in loadedMods and "Arcana" in loadedMods) then goto skipFutaraZanaPatch end
modName = "Futara's Dragon Race and Sva's Arcana"

xpcall(|| -> do
    -- Disables the Lua-smuggling-dependent code used by Arcana's Grand Cross Zȧnä when Futara's Dragon Race is installed.
    local zanaScriptPath = "/items/active/unsorted/GrandCrossZana/GrandCrossZana.lua"
    local zanaScript = assets.bytes(zanaScriptPath)

    local zanaScriptPatch = [==[
    ---<< END OF ORIGINAL ZȦNÄ SCRIPT >>---

    InitExtendedCode = function() end
    ]==]

    assets.add(zanaScriptPath, zanaScript .. zanaScriptPatch)

    logInfo(modName)
end, |e| -> do
    logError(modName, e)
end) end

::skipFutaraZanaPatch::