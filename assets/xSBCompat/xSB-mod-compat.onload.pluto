local loadedModPaths = assets.loadedSources()
local loadedMods = {}
local xSBCompatVersion
for loadedModPaths as loadedMod do
    local metadata = assets.sourceMetadata(loadedMod)
    local modName = metadata.name
    table.insert(loadedMods, modName ?? loadedMod)
    if modName == "xSBCompat" then
        xSBCompatVersion = metadata.version
    end
end

if xSBCompatVersion then
    sb.logInfo($"[xSBCompat] Loaded xSBCompat v{xSBCompatVersion} - on-load stage.")
else
    return
end

--- Universal compatibility patch ---

xpcall(|| -> do
    -- Works around various unnecessary OpenStarbound "compatibility" checks that exclude xStarbound for various stupid, non-technical reasons.
    assets.add("/opensb/coconut.png", assets.newImage({0, 0})) -- Yes, this has been used for unneeded "compatibility" checks.
    assets.add("/scripts/xsb/dummy.lua", "--- Dummy script asset. ---")

    local worldServerConfig = assets.json("/worldserver.config")
    worldServerConfig.scriptContexts.OpenStarbound ??= jarray{"/scripts/xsb/dummy.lua"}
    assets.add("/worldserver.config", worldServerConfig)

    local clientConfig = assets.json("/client.config")
    clientConfig.universeScriptContexts.OpenStarbound ??= jarray{"/scripts/xsb/dummy.lua"}
    assets.add("/client.config", clientConfig)

    local playerConfig = assets.json("/player.config")
    playerConfig.genericScriptContexts.OpenStarbound ??= "/scripts/xsb/dummy.lua"
    assets.add("/player.config", playerConfig)

    sb.logInfo($"[xSBCompat] Applied universal compatibility patch")
end, |e| -> do
    sb.logError($"[xSBCompat] Error while applying universal compatibility patch: {e}")
end) end